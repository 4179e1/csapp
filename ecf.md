# 异常控制流(Exception Control Flow)

## 异常的类型

| 类别            | 原因              | 例子                            | 异步/同步 | 返回行为             |
| --------------- | ----------------- | ------------------------------- | --------- | -------------------- |
| 中断(interrupt) | 来自I/O设备的信号 | 网卡收到数据包                  | 异步      | 总是返回到下一条指令 |
| 陷阱(trap)      | 有意的异常，      | 系统调用                        | 同步      | 总是返回到下一条指令 |
| 故障(fault)     | 潜在可恢复的错误  | Page Fault，Segment Fault       | 同步      | 可能返回到当前指令   |
| 终止(abort)     | 不可回复的错误    | Machine Check？内存奇偶校验错误 | 同步      | 不会返回             |

- 异步异常是由处理器外部的I/O设备中的时间产生的。
- 同步异常是执行一条指令的直接产物

## 进程

关键抽象

- 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
- 一个私有的地址空间，它提供一个家乡，好像我们的程序独占地使用内存系统。

### 进程空间地址

| 地址                 |                                    |
| -------------------- | ---------------------------------- |
| 用户代码不可见的内存 | 内核虚拟内存（代码、数据、堆、栈） |
| 2^24 - 1             |
| %rsp                 | 用户栈（运行时创建）               |
|                      | 用户栈增长方向 v                   |
|                      | ...                                |
|                      | 共享库增长方向 ^                   |
|                      | 共享库的内存映射区域               |
|                      | 共享库的内存映射区域               |
|                      | ...                                |
|                      | 运行时堆增长方向 ^                 |
| brk                  | 运行时堆(malloc)                   |
| 读/写段              | .bss                               |
|                      | .data                              |
| 只读代码段           | .init, .text, .rodata              |
| 0x400000             |                                    |
| 0                    |                                    |

### 上下文切换

多个进程轮流使用处理器。每个进程执行它的控制流的一部分，然后被抢占（preempted）（暂时挂起），然后轮到其他进程。

在进程执行的某些时刻，内核可以决定抢占的当前进程，并且重新开始一个先前被抢占的进程。这种哦鞥决策就叫做调度（scheduling）。

- 当内核代表用户执行系统调用时，可能会发生上下文切换（即使系统调用没有阻塞）。
- 中断也可能引发上下文切换。比如，每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。

> 什么是抢占式？什么是非抢占式